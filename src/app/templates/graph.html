<head>
  <style> body { margin: 0; } </style>

<script src="//unpkg.com/three"></script>

  <script src="//unpkg.com/3d-force-graph"></script>
  <!--<script src="../../dist/3d-force-graph.js"></script>-->
  <style>
    .clickable { cursor: unset !important }
  </style>
</head>

<body>
  <div id="3d-graph"></div>

    <script>

      var gData = {{graph |tojson| safe}};

      for (const [key, value] of Object.entries(gData["nodes"])) {
          value["childLinks"] = [];
          value["collapsed"] = false;
      }

      const nodesById = Object.fromEntries(gData.nodes.map(node => [node.id, node]));
      gData.links.forEach(link => {
        nodesById[link.source].childLinks.push(link);
      });

      console.log(gData);

      var collap = false;
      var showImages = false;

      const getPrunedTree = (id) => {
        const visibleNodes = [];
        const visibleLinks = [];
        var start_id = id;
        var start = true;

        console.log(start_id);
        console.log(start);
        
        (function traverseTree(node = nodesById[id]) {
          visibleNodes.push(node);
          if (!node.collapsed) return;
          if (!start) {
            return;
          } else{
          start = false;
          }

          visibleLinks.push(...node.childLinks);
          console.log(visibleNodes);
          node.childLinks
            .map(link => ((typeof link.target) === 'object') ? link.target : nodesById[link.target]) 
            .forEach(traverseTree);
        })(); 
        return { nodes: visibleNodes, links: visibleLinks };
      };
      const elem = document.getElementById('3d-graph');

      const Graph = ForceGraph3D()
        .graphData(gData)
        .nodeLabel(node => node.id)
        .linkWidth(link => ((link.weight*100)* (link.weight*100))/1000)
        .linkOpacity(link => (1-link.weight)*(1-link.weight))
        .onNodeClick(node => {
          if (!collap){
            if (node.childLinks.length) {
              node.collapsed = !node.collapsed; 
              Graph.graphData(getPrunedTree(node.id));
              collap = true;
            }
          } else {
            Graph.graphData(gData);
            collap = false;
          }

          })

        .onNodeRightClick(node => {
          if (!showImages) {
            showClusterImages(node);
            showImages = true;
          } else {
            removeDisplay(node);
            showImages = false;
          }
        }
          )

        (document.getElementById('3d-graph'))
        .nodeThreeObject(({ id }) => {
          const imgTexture = new THREE.TextureLoader().load(`./static/clusters/${id}_0.jpg`);
          const material = new THREE.SpriteMaterial({ map: imgTexture });
          const sprite = new THREE.Sprite(material); 
          sprite.scale.set(25, 15);
          return sprite;
        });

      const linkForce = Graph
        .d3Force('link')
        .distance(link => (((1-link.weight)*500)*((1-link.weight)*500))/1000);

      function showClusterImages(id) {
        var yAxis = 35;
        var xAxis = 50;

        Graph.scene().add(Graph.camera());
        var meshes = {};

        for (let i = 0; i < 10; i++) {
          plan = new THREE.PlaneGeometry(25, 15, 1, 1);
          var map = new THREE.TextureLoader().load( `./static/clusters/${id.id}_${i}.jpg`);
          var material = new THREE.MeshBasicMaterial( { map: map } );
          const mesh = new THREE.Mesh(plan , material);
          meshes[i] = mesh;
        }

        for(var p in meshes){
          Graph.camera().add(meshes[p]);
          meshes[p].position.set(xAxis,yAxis,-100);
          yAxis -= 17;

          if (p == 4){
            yAxis = 35;
            xAxis = 76;
          }
        }

      }

      function removeDisplay(){
        Graph.scene().remove(Graph.camera());
      }

  </script>
</body>
